{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","text","trim","test","categories","undefined","find","category","type","className","placeholder","value","onChange","target","getGifs","a","endPoint","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","url","images","downsized_medium","GifGridItem","src","alt","GifGrid","loading","state","setState","useEffect","then","useFetchGifs","key","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"6MAGaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EACRC,mBAAS,IADD,mBACrCC,EADqC,KACzBC,EADyB,KA0C5C,OAEI,0BAAMC,SAlCW,SAACC,GAElBA,EAAEC,iBAEF,IAAMC,EAAOL,EAAWM,OAER,mCAEJC,KAAKF,IAEbP,GAAc,SAACU,GAKX,YAAcC,IAFAD,EAAWE,MAAK,SAACC,GAAD,OAAcA,IAAaN,MAIrDJ,EAAc,IAGR,CAAEI,GAAR,mBAAgBG,MAIhBP,EAAc,IAEP,YAAIO,SAWnB,2BACII,KAAO,OACPC,UAAU,eACVC,YAAc,uBACdC,MAASf,EACTgB,SAhDc,SAACb,GAGvBF,EAAcE,EAAEc,OAAOF,Y,uBCRdG,EAAO,uCAAG,WAAMP,GAAN,uBAAAQ,EAAA,4DACJ,mCAETC,EAHa,iDAGwCC,UAAUV,GAHlD,qCACJ,oCADI,SAKAW,MAAMF,GALN,cAKbG,EALa,gBAOEA,EAAKC,OAPP,uBAOZC,EAPY,EAOZA,KAEDC,EAAOD,EAAKE,KAAI,SAACC,GAAO,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXC,IAAG,UAAEH,EAAII,cAAN,aAAE,EAAYC,iBAAiBF,QAbvB,kBAkBZL,GAlBY,4CAAH,sDCAXQ,EAAc,SAAC,GAAiB,IAAhBH,EAAe,EAAfA,IAAID,EAAW,EAAXA,MAC7B,OACI,yBAAKjB,UAAY,0CACb,yBAAKsB,IAAMJ,EAAKK,IAAON,IACvB,2BAAIA,KCkCDO,EAnCC,SAAC,GAAgB,IAAf1B,EAAc,EAAdA,SAAc,ECFJ,SAACA,GAAa,MAQZZ,mBAAS,CAC/B0B,KAAM,GACNa,SAAS,IAVyB,mBAQ/BC,EAR+B,KAQxBC,EARwB,KAgCtC,OAbAC,qBAAU,WAKNvB,EAAQP,GAAU+B,MAAK,SAAChB,GACpBc,EAAS,CACLf,KAAMC,EACNY,SAAS,SAGlB,CAAC3B,IAEG4B,EDzBuBI,CAAahC,GAA/BqB,EALgB,EAKrBP,KAAYa,EALS,EAKTA,QAEnB,OACI,oCACI,4BAAK3B,GACH2B,GAAY,uBAAGzB,UAAU,oCAAb,gBACd,yBAAKA,UAAU,aAMHmB,EAAOL,KAAI,SAACC,GAAD,OAEP,kBAAC,EAAD,eACIgB,IAAOhB,EAAIC,IAEPD,UEOrBiB,EA7BM,WAAM,MAGa9C,mBAAS,CAAC,cAHvB,mBAGhBS,EAHgB,KAGJV,EAHI,KAKvB,OAEI,oCAEI,4CAGA,kBAAC,EAAD,CAAaA,cAAiBA,IAC9B,6BACA,4BAIQU,EAAWmB,KAAI,SAAChB,GACb,OAAO,kBAAC,EAAD,CAASA,SAAYA,EACnBiC,IAAOjC,UCpBvCmC,IAASC,OACP,kBAAC,EAAD,MACAC,SAASC,eAAe,U","file":"static/js/main.a68a3039.chunk.js","sourcesContent":["import React, { useState } from 'react';\r\nimport PropTypes from 'prop-types'\r\n\r\nexport const AddCategory = ({setCategories}) => {\r\n    const [inputValue, setInputValue] = useState(''); //estado por defecto el input\r\n\r\n    //funcion que maneja el cambio de la caja de texto\r\n    const handleInputChange = (e) => {\r\n        //coloca como nuevo valor al input text el valor del evento a traves de la funcion\r\n        //para cambiar el stado del inputValue\r\n        setInputValue(e.target.value);\r\n    };\r\n    //funcion que maneja el submit del formulario\r\n    const handleSubmit = (e) => {\r\n        //previene la recarga del navegador\r\n        e.preventDefault(); \r\n        //toma el valor contenido en la caja de texto y le quita los espacion\r\n        const text = inputValue.trim(); \r\n        //crea una expresion regular para evaluar\r\n        const PATTERN = /^[a-z-A-Z]([a-z A-Z 0-9]+){3,4}$/;\r\n        //mira si el texto obtenido sigue el patron de la expRegular\r\n        if (PATTERN.test(text)){\r\n            //usa la funcion de establecer el valor de las categorias\r\n            setCategories((categories) => {\r\n                //buscamos si dentro de las categorias ya hay un elemento igual al que \r\n                //viene por la caja de texto\r\n                const found = categories.find((category) => category === text);\r\n                //si no hay en categorias este valor que nos llego\r\n                if (found === undefined){\r\n                    //limpie el valor de la caja de texto \r\n                    setInputValue('');\r\n                    //actualize el estado de las categorias colocando lo que nos llego\r\n                    //en el inicio del array de las categorias y retorne                    \r\n                    return [text,...categories]\r\n                //si encontro el texto en las categorias    \r\n                }else{\r\n                    //limpie la caja a traves de la funcion de cambiar el stado \r\n                    setInputValue('')\r\n                    //returne todas las categorias existentes a traves del spread (...)\r\n                    return [...categories];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    //retorno del componente con algunas funciones de eventos para el\r\n    return (\r\n        // retorna un formulario que dispara un evento al submit\r\n        <form onSubmit = {handleSubmit}>\r\n            {/* detro del submit viene una caja de texto que dispara una funcion al \r\n            evento change */}\r\n            <input \r\n                type = \"text\" \r\n                className=\"add-category\"\r\n                placeholder = 'Ingrese Su Personaje'\r\n                value = {inputValue}\r\n                onChange = {handleInputChange}\r\n            />\r\n        </form>\r\n    )\r\n}\r\n\r\n\r\n\r\nAddCategory.propTypes = {\r\n    setCategories : PropTypes.func.isRequired,\r\n}\r\n\r\n\r\n\r\n"," //funcion que hace peticion fetch tipo get a la api de giphy y es convertida en promesa\r\n    //por el uso del async\r\n    export const getGifs = async(category) => {\r\n        const apiKey = 'OuwmR5EG9B1vMrSEfRufDT8ERXlq3PA1';//apikey mia\r\n        //endpoint completo\r\n        const endPoint = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&lang=es&limit=10&api_key=${apiKey}`;\r\n        //haga peticion get a la url esa y espere hasta que obtenga respuesta\r\n        const resp = await fetch(endPoint);\r\n        //extraiga la data en formato json y siga hasta que termine este proceso a la siguiente linea\r\n        const {data} = await resp.json();\r\n        // retorne un objeto con estas propiedades por cada image\r\n        const gifs = data.map((img)=>{\r\n            return {\r\n                id: img.id,\r\n                title: img.title,\r\n                url: img.images?.downsized_medium.url,\r\n            };\r\n        });\r\n        //establezca el nuevo valor de imagenes usando la funcion del hook useState con el nuevo\r\n        // objeto el cual es envuelto en el array vacio por defecto del images \r\n        return gifs;\r\n    };","import React from 'react'\r\n\r\nexport const GifGridItem = ({url,title}) => {\r\n    return (\r\n        <div className = \"card animate__animated animate__fadeIn\">\r\n            <img src= {url} alt = {title}/>\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs'\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nconst GifGrid = ({category}) => {\r\n    /**\r\n     * desectructura el objeto que viene del state del customHook useFetchGifs el cual \r\n     * devuelve una data, y un flag de loading. la data la renombra como images\r\n     */\r\n    const {data:images,loading} = useFetchGifs(category);\r\n   \r\n    return (\r\n        <>\r\n            <h3>{category}</h3> \r\n            {(loading) && <p className='animate__animated animate__flash'>Cargando....</p>}\r\n            <div className=\"card-grid\">\r\n                {/* imprime la categoria */}\r\n\r\n                    {\r\n                    //rederiza un componente de estos por cada imagen que halla en la coleccion\r\n                    //obtenida por la peticion fetch a giphy\r\n                        images.map((img)=>(\r\n                                            \r\n                            <GifGridItem\r\n                                key = {img.id}\r\n                    //enviamos un objeto de todas las propiedades contenidas en img a los props del componente hijo\r\n                                {...img} \r\n                            />\r\n                        ))\r\n                    } \r\n            </div> \r\n        </>\r\n    )\r\n}\r\n\r\nGifGrid.propTypes = {\r\n    category : PropTypes.string.isRequired,\r\n}\r\n\r\nexport default GifGrid\r\n","import { useState, useEffect } from 'react'\r\nimport { getGifs } from '../helpers/getGifs';\r\n\r\nexport const useFetchGifs = (category) => {\r\n\r\n    /**\r\n     * desestructura lo que devuleve el useState que es el state y una funcion para\r\n     * cambiar el state. el estado inicial del component es lo que esta dentro\r\n     * de useState\r\n     */\r\n\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true,\r\n    });\r\n\r\n    /**\r\n     * Este useEffect indica que voy a ejecutar lo que esta dentro del callback\r\n     * solo al momento de renderizar el componente una unica vez y solo al cambiar \r\n     * la categoria vuelve y ejecuta la funcion. si hay otro cambio en este componente\r\n     * lo que esta por dentro del callback no se ejecuta\r\n     */\r\n    useEffect(() => {\r\n        /**\r\n         * Hace la peticion get y espera el los gifs d la peticion si todo sale bien\r\n         * si algo sale mal ya se sabe que es con un cath ya que esto es una promesa\r\n         */\r\n        getGifs(category).then((gifs) => {\r\n            setState({\r\n                data: gifs,\r\n                loading: false,\r\n            });\r\n        });\r\n    }, [category]); //solo vuelve a ejecutar si la categoria cambia si no no hace nada\r\n    //retorna el estado\r\n    return state;\r\n}\r\n","import React, { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport GifGrid from './components/GifGrid';\r\n\r\n\r\nconst GifExpertApp = () => {\r\n    //establece el stado incial del componente y la funcion para \r\n    //modificar el estado\r\n    const [categories, setCategories] = useState(['One Punch']);\r\n    //retorne esto\r\n    return (\r\n        // un fragment \r\n        <> \r\n        {/* imprime en un h2 esto */}\r\n            <h2>GifExpertApp</h2>\r\n            {/* llame a este componente y se le envia la funcion con la que se altera\r\n            las categorias */}\r\n            <AddCategory setCategories = {setCategories} />\r\n            <hr/>\r\n            <ol>\r\n                {/* llama al componente por cada categoria que hay enviuando en los \r\n                props la categoria y como key del componente pone la categoria */}\r\n                {\r\n                    categories.map((category) => {\r\n                       return <GifGrid category = {category}\r\n                                key = {category}\r\n                                />\r\n                    })\r\n                }\r\n            </ol>\r\n        </>\r\n    );\r\n};\r\n\r\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport GifExpertApp from './GifExpertApp';\n\nReactDOM.render(\n  <GifExpertApp />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}